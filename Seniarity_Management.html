<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>NAD Seniority & Promotion Management</title>
</head>
<body>
  <h2>NAD Seniority & Promotion Management</h2>

  <h3>Search Employee</h3>
  <input type="text" id="tokenInput" placeholder="Enter Token Number" oninput="showSuggestions()">
  <div id="suggestions" style="border:1px solid #ccc;display:none;"></div>
  <button onclick="searchEmployee()">Search</button>

  <div id="employeeDetails"></div>

  <script>
// Links to published CSV exports
const sheet1URL = "https://docs.google.com/spreadsheets/d/1_qwciFgPC98jL9-4j4p7qLTK639xF0Gkrddp9E4bGQo/export?format=csv&gid=0";
const sheet2URL = "https://docs.google.com/spreadsheets/d/1_qwciFgPC98jL9-4j4p7qLTK639xF0Gkrddp9E4bGQo/export?format=csv&gid=378290522";

let employees = [];
let sanctionedPosts = [];
let headers1 = [];
let headers2 = [];

// Robust CSV parser
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cell = "";
  let insideQuote = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    if (char === '"') {
      if (insideQuote && text[i + 1] === '"') {
        cell += '"';
        i++;
      } else {
        insideQuote = !insideQuote;
      }
    } else if (char === ',' && !insideQuote) {
      row.push(cell);
      cell = "";
    } else if ((char === '\n' || char === '\r') && !insideQuote) {
      if (cell || row.length) {
        row.push(cell);
        rows.push(row);
        row = [];
        cell = "";
      }
    } else {
      cell += char;
    }
  }
  if (cell || row.length) row.push(cell), rows.push(row);
  return rows;
}

// Load both sheets
async function loadData() {
  try {
    // Sheet1
    const res1 = await fetch(sheet1URL);
    const text1 = await res1.text();
    const rows1 = parseCSV(text1);
    headers1 = rows1[0];
    employees = rows1.slice(1).map(r => {
      let obj = {};
      headers1.forEach((h, i) => obj[h] = r[i] || "");
      return obj;
    });

    // Sheet2
    const res2 = await fetch(sheet2URL);
    const text2 = await res2.text();
    const rows2 = parseCSV(text2);
    headers2 = rows2[0];
    sanctionedPosts = rows2.slice(1).map(r => {
      let obj = {};
      headers2.forEach((h, i) => obj[h] = r[i] || "");
      return obj;
    });
  } catch (err) {
    console.error("Error loading sheets", err);
  }
}

// Autocomplete Suggestions
function showSuggestions() {
  const input = document.getElementById("tokenInput").value.trim().toLowerCase();
  const suggestionsDiv = document.getElementById("suggestions");
  suggestionsDiv.innerHTML = "";
  if (input.length < 2) {
    suggestionsDiv.style.display = "none";
    return;
  }
  const matches = employees.filter(e => (e["Tokan No."] || "").toLowerCase().includes(input)).slice(0, 5);
  matches.forEach(emp => {
    const div = document.createElement("div");
    div.textContent = `${emp["Tokan No."]} - ${emp["Name"]}`;
    div.style.cursor = "pointer";
    div.onclick = () => {
      document.getElementById("tokenInput").value = emp["Tokan No."];
      suggestionsDiv.style.display = "none";
      searchEmployee();
    };
    suggestionsDiv.appendChild(div);
  });
  suggestionsDiv.style.display = matches.length > 0 ? "block" : "none";
}

// Utility: Parse date (DD/MM/YYYY or YYYY-MM-DD supported)
function parseDate(str) {
  if (!str) return null;
  const parts = str.includes("/") ? str.split("/") : str.split("-");
  if (parts.length === 3) {
    let d = parseInt(parts[0]), m = parseInt(parts[1]) - 1, y = parseInt(parts[2]);
    if (y < 100) y += 2000; // handle YY format
    return new Date(y, m, d);
  }
  return null;
}

// Show Seniority List for same Post & Rank
function showSeniority(emp) {
  const listDiv = document.createElement("div");
  listDiv.innerHTML = `<h4>Seniority in ${emp["Post"]} – ${emp["Rank"]}</h4>`;

  // Get sanctioned posts info
  const postInfo = sanctionedPosts.find(p => p["Post"] === emp["Post"] && p["Rank"] === emp["Rank"]);
  const totalSanctioned = postInfo ? parseInt(postInfo["Sactioned vacancy"]) || 0 : "N/A";

  // Collect peers
  let peers = employees.filter(e => e["Post"] === emp["Post"] && e["Rank"] === emp["Rank"]);
  peers.forEach(p => p._dateRank = parseDate(p[`Date of ${emp["Rank"]}`]) || parseDate(p["Date of Appointment"]));

  // Sort by date of current rank
  peers.sort((a,b) => a._dateRank - b._dateRank);

  // Build list
  let html = `<p>Total Sanctioned: ${totalSanctioned}, Present: ${peers.length}</p>`;
  html += "<ol>";
  peers.forEach(p => {
    const highlight = (p["Tokan No."] === emp["Tokan No."]) ? "style='background:yellow;'" : "";
    const dateStr = p._dateRank ? p._dateRank.toLocaleDateString("en-GB") : "N/A";
    html += `<li ${highlight}>${p["Name"]} (Token ${p["Tokan No."]}) – DoR: ${p["Date of Retirement"]} – Rank Date: ${dateStr}</li>`;
  });
  html += "</ol>";
  listDiv.innerHTML += html;

  return listDiv.outerHTML;
}

// Calculate Promotion Timeline with retirements
function promotionTimeline(emp) {
  const rankOrder = ["USL","SSK","Tradesman Mate","SK","HSK II","HSK I","MCM"];
  const idx = rankOrder.indexOf(emp["Rank"]);
  if (idx === -1) return "<p>Rank not in promotion ladder</p>";

  const retirementDate = parseDate(emp["Date of Retirement"]);
  if (!retirementDate) return "<p>No retirement date available</p>";

  let html = "<ul>";

  for (let i = idx+1; i < rankOrder.length; i++) {
    const nextRank = rankOrder[i];
    const sancInfo = sanctionedPosts.find(p => p["Post"]===emp["Post"] && p["Rank"]===nextRank);
    const sanctioned = sancInfo ? parseInt(sancInfo["Sactioned vacancy"]) || 0 : 0;
    if (sanctioned === 0) {
      html += `<li>${emp["Post"]} ${nextRank} → No sanctioned posts</li>`;
      continue;
    }

    // All candidates in nextRank
    let candidates = employees.filter(e => e["Post"]===emp["Post"] && e["Rank"]===nextRank);
    candidates.forEach(c => {
      c._dateRank = parseDate(c[`Date of ${nextRank}`]) || parseDate(c["Date of Appointment"]);
      c._retire = parseDate(c["Date of Retirement"]);
    });
    candidates.sort((a,b) => a._dateRank - b._dateRank || (a["Tokan No."]||"").localeCompare(b["Tokan No."]));

    // How many seniors ahead in nextRank
    let position = candidates.length + 1; // worst case: he comes after all
    let year = new Date().getFullYear();
    let foundYear = null;

    while (year <= retirementDate.getFullYear() && !foundYear) {
      const retiresThisYear = candidates.filter(c => c._retire && c._retire.getFullYear() === year).length;
      position -= retiresThisYear;
      if (position <= sanctioned) {
        foundYear = year;
      }
      year++;
    }

    if (foundYear) {
      html += `<li>${emp["Post"]} ${nextRank} → ${foundYear} 
                 (Sanctioned: ${sanctioned}, Seniors: ${candidates.length})</li>`;
    } else {
      html += `<li>${emp["Post"]} ${nextRank} → Not Promoted (Retired ${retirementDate.getFullYear()})</li>`;
      break; // stop further promotions
    }
  }

  html += `<li>Retirement → ${retirementDate.getFullYear()}</li>`;
  html += "</ul>";
  return html;
}

// Extend searchEmployee to include seniority list
const oldSearchEmployee = searchEmployee;
searchEmployee = function() {
  oldSearchEmployee();
  const token = document.getElementById("tokenInput").value.trim();
  const div = document.getElementById("employeeDetails");
  const emp = employees.find(e => e["Tokan No."] === token);
  if (emp) {
    div.innerHTML += showSeniority(emp);
  }
};

window.onload = loadData;
</script>

</body>
</html>